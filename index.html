<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Chat Multiplayer + Jogo 3D</title>
  <style>
    body { margin:0; overflow:hidden; font-family: Arial, sans-serif; }
    #chat { position:fixed; bottom:10px; left:10px; width:300px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:8px; z-index:1000; }
    #messages { list-style: none; padding: 0; max-height:150px; overflow-y:auto; font-family: monospace; font-size:14px; }
    #messages li { padding: 3px; margin-bottom: 3px; border-bottom: 1px solid #444; }
    #form { display: flex; margin-top: 5px; }
    #input { flex: 1; padding: 6px; background:#222; color:white; border:1px solid #555; border-radius:4px; }
    #send { padding: 6px; background:#0084ff; color:white; border:none; border-radius:4px; cursor:pointer; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="chat">
    <h3>Chat Multiplayer</h3>
    <ul id="messages"></ul>
    <form id="form">
      <input id="input" autocomplete="off" placeholder="Digite sua mensagem..." />
      <button id="send">Enviar</button>
    </form>
  </div>

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // Conecta ao servidor
    const socket = io("https://multiplayer-serve-edson-simplicio.onrender.com");

    let username = prompt("Digite seu nome:");

    const form = document.getElementById("form");
    const input = document.getElementById("input");
    const messages = document.getElementById("messages");

    // === Cena 3D ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0,1.5,5);

    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(5,5,5);
    scene.add(light);

    // === Personagem local ===
    const localChar = criarCharacterr();
    scene.add(localChar);

    // Braço em primeira pessoa
    const armMesh = new THREE.Mesh(
      new THREE.BoxGeometry(0.2,0.6,0.2),
      new THREE.MeshStandardMaterial({ color:0xffff00 })
    );
    scene.add(armMesh);

    let isFirstPerson = false; // alterna entre modos

    // Função para criar personagem
    function criarCharacterr() {
      const characterr = new THREE.Group();
      const corpoMat = new THREE.MeshStandardMaterial({ color: 0x3333ff });

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.04), corpoMat);
      body.position.y = 0.05;
      characterr.add(body);

      const cabeca = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.06), corpoMat);
      cabeca.position.y = 0.14;
      characterr.add(cabeca);

      return characterr;
    }

    // Lista de jogadores online
    const players = {};

    // Receber atualização de jogadores
    socket.on("playerUpdate", (data) => {
      if (!players[data.id]) {
        const novo = criarCharacterr();
        scene.add(novo);
        players[data.id] = novo;
      }
      players[data.id].position.set(data.x, data.y, data.z);
      players[data.id].rotation.y = data.rot;
    });

    // Remover jogador desconectado
    socket.on("playerDisconnect", (id) => {
      if (players[id]) {
        scene.remove(players[id]);
        delete players[id];
      }
    });

    // Atualizar posição local periodicamente
    setInterval(() => {
      socket.emit("playerUpdate", {
        x: localChar.position.x,
        y: localChar.position.y,
        z: localChar.position.z,
        rot: localChar.rotation.y
      });
    }, 50);

    // === Chat ===
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      if (input.value) {
        socket.emit("chatMessage", { user: username, text: input.value });
        input.value = "";
      }
    });

    socket.on("chatMessage", (msg) => {
      const li = document.createElement("li");
      li.textContent = msg.user + ": " + msg.text;
      messages.appendChild(li);
      messages.scrollTop = messages.scrollHeight;

      // Comandos especiais (objetos 3D)
      switch(msg.text.toLowerCase()) {
        case "cubo":
          const cube = new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshStandardMaterial({ color:0x888888 })
          );
          cube.position.set(Math.random()*4-2,0,Math.random()*4-2);
          scene.add(cube);
          break;
        case "vaquinha":
          const vaca = new THREE.Mesh(
            new THREE.BoxGeometry(1,1,2),
            new THREE.MeshStandardMaterial({ color:0x552200 })
          );
          vaca.position.set(Math.random()*4-2,0,Math.random()*4-2);
          scene.add(vaca);
          break;
        case "inimigo":
          const inimigo = new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshStandardMaterial({ color:0xff0000 })
          );
          inimigo.position.set(Math.random()*4-2,0,Math.random()*4-2);
          scene.add(inimigo);
          break;
      }
    });

    // === Loop de animação ===
    function animate() {
      requestAnimationFrame(animate);

      // Atualiza braço em primeira pessoa
      if (isFirstPerson) {
        const offset = new THREE.Vector3(0.7, -0.5, -1.3);
        const armPosition = offset.clone().applyQuaternion(camera.quaternion);
        armMesh.position.copy(camera.position.clone().add(armPosition));
        armMesh.quaternion.copy(camera.quaternion);
        armMesh.visible = true;
        localChar.visible = false;
      } else {
        armMesh.visible = false;
        localChar.visible = true;
      }

      renderer.render(scene, camera);
    }
    animate();

    // Alternar modo com tecla "M"
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "m") {
        isFirstPerson = !isFirstPerson;
      }
    });

    // Ajuste de tela
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
